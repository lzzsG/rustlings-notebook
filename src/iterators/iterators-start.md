# iterators

---

åœ¨ Rust ç¼–ç¨‹è¯­è¨€ä¸­ï¼Œè¿­ä»£å™¨æ˜¯å¤„ç†é›†åˆæ•°æ®çš„å¼ºå¤§å·¥å…·ï¼Œå…è®¸ä½ ä»¥é«˜æ•ˆå’Œè¡¨è¾¾æ€§å¼ºçš„æ–¹å¼è¿›è¡Œæ•°æ®éå†å’Œè½¬æ¢ã€‚ä»¥ä¸‹æ˜¯ä¸€ç³»åˆ—ä¸“é—¨é’ˆå¯¹è¿­ä»£å™¨ä½¿ç”¨çš„ç»ƒä¹ ï¼Œé€šè¿‡è¿™äº›ç»ƒä¹ ï¼Œä½ å°†æ·±å…¥ç†è§£è¿­ä»£å™¨çš„å„ç§æ“ä½œï¼Œå¹¶åº”ç”¨å®ƒä»¬æ¥è§£å†³å®é™…é—®é¢˜ã€‚

#### è¿­ä»£å™¨ç»ƒä¹  1ï¼šè¿­ä»£å™¨åŸºç¡€

åœ¨è¿™ä¸ªç»ƒä¹ ä¸­ï¼Œä½ å°†é€šè¿‡å¡«å……ä»£ç æ¥åˆ›å»ºå’Œä½¿ç”¨è¿­ä»£å™¨ï¼Œå­¦ä¹ å¦‚ä½•ä»ä¸€ä¸ªç®€å•çš„å­—ç¬¦ä¸²æ•°ç»„å¼€å§‹ï¼Œä½¿ç”¨è¿­ä»£å™¨é€æ­¥è®¿é—®æ¯ä¸ªå…ƒç´ ã€‚è¿™æ˜¯å­¦ä¹ è¿­ä»£å™¨æ“ä½œçš„åŸºç¡€ï¼Œå¸®åŠ©ä½ ç†è§£å¦‚ä½•åœ¨ Rust ä¸­å¼€å§‹è¿­ä»£è¿‡ç¨‹ï¼Œå¹¶æŒæ¡è¿­ä»£å™¨çš„åŸºæœ¬ä½¿ç”¨æ–¹å¼ã€‚

#### è¿­ä»£å™¨ç»ƒä¹  2ï¼šå­—ç¬¦ä¸²é¦–å­—æ¯å¤§å†™

æ­¤ç»ƒä¹ å°†å¼•å¯¼ä½ ä½¿ç”¨è¿­ä»£å™¨å¯¹å­—ç¬¦ä¸²æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ è¿›è¡Œå¤„ç†ï¼Œå…·ä½“æ˜¯å°†æ¯ä¸ªå­—ç¬¦ä¸²çš„é¦–å­—æ¯è½¬æ¢ä¸ºå¤§å†™ã€‚ä½ å°†å­¦ä¹ å¦‚ä½•ç»“åˆè¿­ä»£å™¨å’Œå­—ç¬¦ä¸²å¤„ç†åŠŸèƒ½ï¼Œä»¥å‡½æ•°å¼ç¼–ç¨‹çš„æ–¹å¼æ”¹é€ å’Œç®€åŒ–ä»£ç ã€‚

#### è¿­ä»£å™¨ç»ƒä¹  3ï¼šå¤æ‚çš„é”™è¯¯å¤„ç†

åœ¨è¿™ä¸ªè¾ƒä¸ºå¤æ‚çš„ç»ƒä¹ ä¸­ï¼Œä½ å°†å¤„ç†å¯èƒ½å‘ç”Ÿé”™è¯¯çš„è¿ç®—ï¼Œå­¦ä¹ å¦‚ä½•ä½¿ç”¨è¿­ä»£å™¨ç®¡ç†é”™è¯¯ã€‚é€šè¿‡å®ç°ä¸€ä¸ªé™¤æ³•å‡½æ•°å¹¶å¤„ç†å…¶å¯èƒ½çš„é”™è¯¯ï¼Œä½ éœ€è¦ä½¿ç”¨è¿­ä»£å™¨æ¥æ”¶é›†æ“ä½œç»“æœï¼Œè¿™å°†æ¶‰åŠåˆ°å¯¹è¿­ä»£å™¨æ›´é«˜çº§çš„ä½¿ç”¨ï¼Œå¦‚ `collect` æ–¹æ³•åŠå…¶ä¸ `Result` ç±»å‹çš„ç»“åˆã€‚

#### è¿­ä»£å™¨ç»ƒä¹  4ï¼šè®¡ç®—é˜¶ä¹˜

è¿™ä¸ªç»ƒä¹ æŒ‘æˆ˜ä½ ä½¿ç”¨è¿­ä»£å™¨æ¥è®¡ç®—é˜¶ä¹˜ï¼Œä¸ä½¿ç”¨ä¼ ç»Ÿçš„å¾ªç¯æˆ–é€’å½’æ–¹æ³•ã€‚ä½ å°†æ¢ç´¢å¦‚ä½•ä½¿ç”¨ `fold` æˆ–å…¶ä»–è¿­ä»£å™¨æ–¹æ³•æ¥ç´¯è®¡å€¼ï¼Œè¿™æ˜¯ä¸€ä¸ªéå¸¸å¥½çš„å®è·µï¼Œå¯ä»¥åŠ æ·±ä½ å¯¹è¿­ä»£å™¨å¦‚ä½•åœ¨èƒŒåå¤„ç†æ•°æ®çš„ç†è§£ã€‚

#### è¿­ä»£å™¨ç»ƒä¹  5ï¼šé«˜çº§æ•°æ®ç»Ÿè®¡

æœ€åä¸€ä¸ªç»ƒä¹ å°†è¦æ±‚ä½ ç»Ÿè®¡ä¸€ç³»åˆ—æ•£åˆ—è¡¨ï¼ˆHashMapï¼‰ä¸­çš„æ•°æ®ï¼Œè¿™äº›æ•£åˆ—è¡¨è®°å½•äº†æŸäº›é¡¹ç›®çš„å®ŒæˆçŠ¶æ€ã€‚ä½ å°†ä½¿ç”¨è¿­ä»£å™¨æ¥éå†å¹¶ç»Ÿè®¡ç‰¹å®šçŠ¶æ€çš„å‡ºç°æ¬¡æ•°ï¼Œè¿™ä¸ä»…æµ‹è¯•äº†ä½ å¯¹è¿­ä»£å™¨çš„ç†è§£ï¼Œè¿˜åŒ…æ‹¬äº†å¯¹æ›´å¤æ‚æ•°æ®ç»“æ„çš„å¤„ç†ã€‚

é€šè¿‡è¿™äº›ç»ƒä¹ ï¼Œä½ å°†è·å¾—ä½¿ç”¨ Rust è¿­ä»£å™¨è¿›è¡Œæœ‰æ•ˆç¼–ç¨‹çš„å®é™…ç»éªŒï¼Œå­¦ä¼šå¦‚ä½•åˆ©ç”¨å®ƒä»¬è§£å†³å…·ä½“é—®é¢˜ï¼Œå¹¶ä¼˜åŒ–ä½ çš„ä»£ç ç»“æ„å’Œæ€§èƒ½ã€‚

---

```rust
// ä½ ä¸å¿…ç°åœ¨ç†è§£ä»¥ä¸‹ä»£ç ï¼Œä¸è¿‡ä½ å¯ä»¥å°è¯•è¿è¡Œå®ƒã€‚

use std::collections::HashMap;

struct Adventure {
    challenges: Vec<String>,
    secret_codes: HashMap<String, i32>,
}

impl Adventure {
    fn new() -> Self {
        Adventure {
            challenges: vec![
                "decode the ancient text".to_string(),
                "unravel the secret of the stones".to_string(),
                "find the hidden path".to_string(),
            ],
            secret_codes: HashMap::new(),
        }
    }

    fn begin_journey(&mut self) {
        for challenge in self.challenges.iter() {
            println!("Challenge: {}", challenge);
        }

        let mut modified_challenges: Vec<String> = self.challenges.iter()
            .map(|c| c.chars().next().unwrap().to_uppercase().collect::<String>() + c.split_at(1).1)
            .collect();
        
        println!("Modified Challenges: {:?}", modified_challenges);

        self.secret_codes.insert("Decode the ancient text".to_string(), 9);
        let result: Result<Vec<_>, _> = self.secret_codes.iter()
            .map(|(key, &value)| {
                if key == "Decode the ancient text" && value == 9 {
                    Ok(value)
                } else {
                    Err("Secret code mismatch")
                }
            })
            .collect();

        match result {
            Ok(codes) => println!("Collected secret codes: {:?}", codes),
            Err(e) => println!("Error encountered: {}", e),
        }

        let factorials: Vec<_> = (1..=9).map(|n| (1..=n).fold(1, |acc, i| acc * i)).collect();
        println!("Calculated: {:?}", factorials);

        let count = modified_challenges.iter().filter(|&m| m.contains("the")).count();
        println!("Count of secrets: {}", count);
    }
}

fn main() {
    let mut adventure = Adventure::new();
    adventure.begin_journey();

    println!("\nğŸŒ²Your journey continues into the dark forest.ğŸŒ²ğŸŒ²");
}
```

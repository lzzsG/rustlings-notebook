# Exercise 85

- Name: ```macros2```
- Path: ```exercises/macros/macros2.rs```
#### Hint: 

Macros don't quite play by the same rules as the rest of Rust, in terms of what's available where.

Unlike other things in Rust, the order of "where you define a macro" versus "where you use it" actually matters.


---



```rust,editable
// macros2.rs
//
// Execute `rustlings hint macros2` or use the `hint` watch subcommand for a
// hint.

// I AM NOT DONE

fn main() {
    my_macro!();
}

macro_rules! my_macro {
    () => {
        println!("Check out my macro!");
    };
}

```

---

### 本题内容

这个练习旨在帮助学习者理解 Rust 中宏定义和调用的顺序问题。Rust 中的宏和其他语言特性不同，其定义位置相对于使用位置非常重要。本练习将帮助你理解如何正确放置宏定义以确保其能被正确调用。

### 相关知识点

1. **宏的定义顺序**：
   - 在 Rust 中，宏必须在其被调用之前定义。这是因为 Rust 的宏展开是在编译时进行的，编译器在处理代码时需要已经知道宏的定义。

2. **作用域和可见性**：
   - 宏遵循与函数类似的作用域和可见性规则，但它们在文件和模块中的处理方式略有不同。宏的定义必须在其第一次被调用的地方之前，无论是在同一个文件还是不同模块中。

3. **宏展开**：
   - 宏在编译时展开，这意味着编译器在看到宏调用时必须已经遇到并处理了对应的宏定义。

### 解题方法

#### 步骤描述

1. **修正宏的位置**：
   - 根据 Rust 的规则，你需要确保 `my_macro` 在 `main` 函数调用它之前就已经被定义。

2. **重构代码**：
   - 将 `my_macro` 的定义移动到 `main` 函数之前。

3. **编译和测试**：
   - 调整宏的位置后，编译代码以确保没有错误。
   - 运行程序，验证输出是否符合预期，即打印出 "Check out my macro!"。

#### 代码示例

修正后的代码示例：

```rust
// macros2.rs

macro_rules! my_macro {
    () => {
        println!("Check out my macro!");
    };
}

fn main() {
    my_macro!();
}
```

通过这个练习，你应该能够理解和掌握在 Rust 中正确放置宏定义的重要性。宏的位置对于程序的正确编译至关重要，因为宏的展开需要在编译时完成。学习这一点将帮助你在将来的 Rust 编程中避免一些常见的宏相关错误。

## 扩展知识点与解答：

### 扩展知识点

1. **宏的编写技巧**：
   宏虽然功能强大，但也易于引入错误，特别是在复杂的宏定义中。一些好的编写习惯包括：
   - 使用描述性的匹配臂名称。
   - 在宏定义中使用适当的注释。
   - 考虑宏的扩展形式和可能的输入场景，避免在未预料到的输入上产生错误。

2. **宏的重用和模块化**：
   宏可以在多个地方重用，创建库时可以将宏设计为可公开访问和重用。为此，可以将宏放在专门的模块中，并使用 `#[macro_export]` 属性来使它们在库之外也能被使用。

3. **宏的性能考虑**：
   - 宏虽然在编译时展开，不增加运行时开销，但复杂的宏可以显著增加编译时间。
   - 理解宏展开后的代码量和复杂性可以帮助优化宏的使用，避免不必要的编译负担。

### 扩展解题方法

1. **测试宏的边界情况**：
   - 在使用宏时，应考虑并测试边界条件和异常输入。为宏编写测试用例可以帮助确保它们在各种情况下都能正常工作。
   - 使用单元测试来验证宏的行为，特别是在宏用于重要的业务逻辑时。

2. **文档和示例**：
   - 为宏编写文档是一种良好的实践，特别是当宏公开给其他开发者使用时。在文档中包括示例调用可以极大地帮助用户理解宏的用途和用法。
   - 使用文档测试（doc-tests）来确保文档中的示例始终保持更新并正确无误。

3. **宏调试**：
   - 调试宏可以比较困难，因为错误可能隐藏在宏的展开过程中。使用 `cargo expand` 或类似工具查看宏展开的结果，可以帮助理解宏在具体情况下的行为。
   - 考虑将复杂的宏逻辑分解成更小的部分，或者使用过程宏来处理更复杂的情况。

通过掌握这些扩展知识点和解题方法，你将能够更有效地使用和设计宏，使其成为强大的工具，以简化代码、提高复用性和加速开发流程。这些技能对于任何使用 Rust 进行系统级或应用级编程的开发者都是极其宝贵的。
